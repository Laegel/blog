{"pageProps":{"content":"<h1 class=\"text-5xl text-primary text-center font-bold mb-6 !leading-tight\">Introduction au typage dans Python</h1><div class=\"text-center text-sm mb-4\">Le 7 février 2022</div><p class=\"mb-4\">Python, le langage dont la popularité ne cesse de croître de par sa facilité d&#39;apprentissage et d&#39;utilisation, catalogué comme LA technologie à utiliser en Machine Learning est, comme beaucoup d&#39;autres, un langage à typage dynamique. \nLe typage dynamique a ses avantages, c&#39;est indéniable : ça permet de développer rapidement en mettant de côté l&#39;inconvénient principal des langages statiques, à savoir (notamment) la déclaration explicite de type lors de la création d&#39;une variable, la rigidité de la gestion des arguments dans les fonctions et j&#39;en passe.</p>\n        <h2 class=\"text-3xl text-primary mb-4\">\n          Quand et pourquoi ?\n        </h2><p class=\"mb-4\">Les propositions visant à théoriser puis introduire les annotations de type dans Python, les <a class=\"text-primary underline underline-offset-1\" target=\"_blank\" rel=\"noreferrer noopener nofollow\" href=\"https://www.python.org/dev/peps/pep-0483/\">PEP 483</a> et <a class=\"text-primary underline underline-offset-1\" target=\"_blank\" rel=\"noreferrer noopener nofollow\" href=\"https://www.python.org/dev/peps/pep-0484/\">PEP 484</a>, ont été créées en 2014. Les propositions ont été étudiées et approuvées, permettant aux annotations de type de finalement faire leur apparition dans la version 3.5 des spécifications du langage.</p><p class=\"mb-4\">L&#39;introduction du système de typage dans Python avait pour but, je cite (en traduisant) :</p><blockquote class=\"italic border-l-4 border-primary pl-2\"><p class=\"mb-4\">de simplifier l&#39;analyse statique et la refactorisation, de potentiellement vérifier le typage à l&#39;exécution du code et (dans certains contextes) de générer du code utilisant des informations de type.</p></blockquote><p class=\"mb-4\">-- <a class=\"text-primary underline underline-offset-1\" target=\"_blank\" rel=\"noreferrer noopener nofollow\" href=\"https://www.python.org/dev/peps/pep-0484/#rationale-and-goals\">source</a></p><p class=\"mb-4\">Dans cet article, je vais surtout m&#39;attarder sur l&#39;analyse statique et la refactorisation, deux techniques exploitées par les dévs au quotidien. <br>L&#39;analyse statique, c&#39;est tout ce qui nous permet de bénéficier d&#39;informations sur l&#39;utilisation de code. Vous voyez les infobulles de vos EDI, les vaguelettes lorsque vous avez mal orthographié une variable ? C&#39;est grâce à de l&#39;analyse statique qu&#39;elles sont pertinentes. <br>La refactorisation est un procédé qui vise à réduire la complexité du code, le rendre plus maintenable, plus efficace en fonction du besoin. Nous sommes amenés à refactoriser du code fréquemment et le typage sert de levier pour nous faciliter le travail.</p><p class=\"mb-4\">A noter que d&#39;autres propositions (<a class=\"text-primary underline underline-offset-1\" target=\"_blank\" rel=\"noreferrer noopener nofollow\" href=\"https://www.python.org/dev/peps/pep-0526/\">PEP 526</a>) ont été ajoutées et d&#39;autres le seront dans l&#39;avenir afin d&#39;enrichir la fonctionnalité de base.</p>\n        <h2 class=\"text-3xl text-primary mb-4\">\n          Comment ça fonctionne en pratique ?\n        </h2>\n      <h3 class=\"text-xl text-primary mb-2\">\n        Exemples simples d&#39;utilisation\n      </h3><p class=\"mb-4\">Le besoin de spécifier un type peut apparaître à plusieurs endroits dans le code.</p><p class=\"mb-4\">En déclarant une variable :</p><pre><code class=\"language-py hljs mb-4 rounded-sm\">name: <span class=\"hljs-built_in\">str</span> = <span class=\"hljs-string\">&quot;Je contiens une chaîne&quot;</span>\n</code></pre>\n<p class=\"mb-4\">Sur les propriétés d&#39;une structure de données :</p><pre><code class=\"language-py hljs mb-4 rounded-sm\"><span class=\"hljs-meta\">@dataclass</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Post</span>:\n    <span class=\"hljs-built_in\">id</span>: <span class=\"hljs-built_in\">int</span>\n    title: <span class=\"hljs-built_in\">str</span>\n    content: <span class=\"hljs-built_in\">str</span>\n</code></pre>\n<p class=\"mb-4\">Sur les arguments et le retour d&#39;une fonction :</p><pre><code class=\"language-py hljs mb-4 rounded-sm\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">multiply</span>(<span class=\"hljs-params\">arg1: <span class=\"hljs-built_in\">int</span>, arg2: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n    <span class=\"hljs-keyword\">return</span> arg1 * arg2\n</code></pre>\n\n      <h3 class=\"text-xl text-primary mb-2\">\n        Typer, oui... mais pas n&#39;importe comment\n      </h3><p class=\"mb-4\">Dans les exemples précédents, j&#39;ai volontairement augmenté la verbosité du code afin de vous illustrer les possibilités.\nDans la réalité, il n&#39;est pas nécessaire de typer tout, tout le temps : la plupart des langages à typage static bénéficient de ce qu&#39;on appelle la déduction de type, grâce à l&#39;analyse statique. </p><p class=\"mb-4\">Il est peu probable que vous deviez préciser le type d&#39;une variable que vous venez d&#39;assigner : </p><pre><code class=\"language-py hljs mb-4 rounded-sm\">name = <span class=\"hljs-string\">&quot;Je contiens une chaîne&quot;</span> <span class=\"hljs-comment\"># Le type de `name` est déduit, c&#x27;est un `str`</span>\n</code></pre>\n<p class=\"mb-4\">sauf si vous utilisez un alias :</p><pre><code class=\"language-py hljs mb-4 rounded-sm\">Token = <span class=\"hljs-built_in\">str</span>\ntoken: Token = <span class=\"hljs-string\">&quot;12345678&quot;</span> <span class=\"hljs-comment\"># Le type a été explicité car il ne pouvait être déduit</span>\n</code></pre>\n<p class=\"mb-4\">Vous n&#39;aurez pas non plus systématiquement besoin de typer les retours de fonctions :</p><pre><code class=\"language-py hljs mb-4 rounded-sm\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">multiply</span>(<span class=\"hljs-params\">arg1: <span class=\"hljs-built_in\">int</span>, arg2: <span class=\"hljs-built_in\">int</span></span>): <span class=\"hljs-comment\"># Le type du retour est déduit, c&#x27;est un `int`</span>\n    <span class=\"hljs-keyword\">return</span> arg1 * arg2\n</code></pre>\n<p class=\"mb-4\">En fait, les seuls moments où ça va s&#39;avérer obligatoire, c&#39;est lorsqu&#39;on va devoir passer par de la définition de structures (telles que les <code>dataclass</code>) ou que les types sont trop ambigus ou inexistants, donc impossibles à déduire.</p>\n        <h2 class=\"text-3xl text-primary mb-4\">\n          Des tas d&#39;outils pratiques pour travailler avec les types\n        </h2><p class=\"mb-4\">En quelques années, la communauté a eu le temps de mettre au point des outils pour se faciliter la vie.<br>Sachant qu&#39;il arrive souvent qu&#39;on utilise une bibliothèque non typée, certains outils peuvent s&#39;avérer particulièrement intéressants puisqu&#39;ils peuvent générer les types en lisant le code : ce sont des générateurs de types.\nEn voici un échantillon :</p><ul class=\"mb-4 list-disc pl-6\"><li><a class=\"text-primary underline underline-offset-1\" target=\"_blank\" rel=\"noreferrer noopener nofollow\" href=\"http://mypy-lang.org/\">mypy</a>, outil d&#39;analyse statique, générateur de types</li>\n<li><a class=\"text-primary underline underline-offset-1\" target=\"_blank\" rel=\"noreferrer noopener nofollow\" href=\"https://pyre-check.org/\">Pyre</a>, outil d&#39;analyse statique, générateur de types</li>\n<li><a class=\"text-primary underline underline-offset-1\" target=\"_blank\" rel=\"noreferrer noopener nofollow\" href=\"https://github.com/microsoft/pyright\">Pyright</a>, outil d&#39;analyse statique, générateur de types + <a class=\"text-primary underline underline-offset-1\" target=\"_blank\" rel=\"noreferrer noopener nofollow\" href=\"https://github.com/microsoft/pylance-release\">Pylance</a>, son extension VS Code</li>\n<li><a class=\"text-primary underline underline-offset-1\" target=\"_blank\" rel=\"noreferrer noopener nofollow\" href=\"https://github.com/Instagram/MonkeyType\">MonkeyType</a>, générateur de types</li>\n</ul><hr class=\"!my-6 m-auto text-primary max-w-screen-md\"/><p class=\"mb-4\">Les annotations en Python ne servent qu&#39;à un seul objectif : <strong>rendre le code plus clair, plus explicite</strong>. Il n&#39;a <em>pas le moindre effet bénéfique lors de son exécution</em> et n&#39;améliore en rien ses performances (les imports des types vont plutôt les réduire de manière <em>négligeable</em>). Bien que leur introduction remonte à 2014, les annotations de type de Python ne sont pas aussi approfondies que ce qu&#39;on pourrait trouver avec TypeScript ou Rust et on peut rapidement se retrouver limité, par exemple avec les types génériques.</p><p class=\"mb-4\">Le point final n&#39;est pas de trancher sur le fait de favoriser un langage à typage statique par rapport à un langage à typage dynamique. A travers cette fonctionnalité, Python se rend plus versatile et, à mon avis, <strong>plus facile à maintenir</strong> dans de grosses applications et ce avec un excellent compromis temps/information grâce à la déduction de type. </p><p class=\"mb-4\">Utilisez-vous les annotations de type dans vos projets Python ? Si non, qu&#39;est-ce qui vous ferait changer d&#39;avis ? <br>Au contraire, voyez-vous des inconvénients majeurs contre leur utilisation ?</p>"},"__N_SSG":true}